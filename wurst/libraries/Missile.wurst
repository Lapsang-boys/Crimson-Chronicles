// TODO: Implement onLifeEnd
// TODO: Make acceleration a method instead of a constructor field/atirtiritritir(?)
package Missile

import DummyRecycler
import TimerUtils
import MapBounds
import ClosureForGroups

import Assets

enum MissileType
    HOMING
    TARGET

// Collision size of missile.
constant COLLISION_SIZE = 128/4
// Frame rate of system in seconds.
constant MISSILE_INTERVAL = 1/32
// Default height (66 units) for launching and aiming missiles from/at units.
constant DEFAULT_HITBOX = 0.66
// Default sfx scale
constant DEFAULT_SCALE = 1.


// TODO: depending on frotty use default values
public abstract class Missile
    unit source                                                     // Caster
    unit target                                                     // Target for homing missiles.

    private unit dummy
    private timer t

    private real ttl                        = 5                     // Time to live before auto-destruct.
    protected real liveTime                 = 0                     // Time since launched.

    protected effect sfx                    = null
    private string sfxPath
    private real scale                      = DEFAULT_SCALE         // SFX scale.

    private vec2 originLoc                  = vec2(0,0)
    private vec2 targetLoc                                          // Target for location aimed spells
    private vec2 currentLoc                 = vec2(0,0)

    private real originZ                    = this.source.getUnitHeight(DEFAULT_HITBOX)
    private real currentZ                   = this.originZ
    private real targetZ

    private real facing                                             // In radians

    private real distanceTraveled           = 0                     // Distance traveled (wc3 units)
    protected real distanceToTarget         = this.originLoc.distanceTo(this.targetLoc)

    private real velocity                                            // WC3 units per second
    private real acceleration                                        // If missile has acceleration

    real arc                                = 0.1                    // How much missile arc (in Z)
    private real turnrate                   = 3/4*PI*MISSILE_INTERVAL    // Sets a turn rate for a missile (in X/Y) [rad per itteration]
    private real turnrateAcceleration       = 0
    real collision                          = COLLISION_SIZE         // Collision size of the missile can be set through method

    MissileType missileType

    // Constructor for missile with unit target
    construct(unit source, unit target, string sfxPath, real velocity)
        this.source = source
        this.target = target

        this.targetLoc = target.getPos()
        this.targetZ = target.getUnitHeight(DEFAULT_HITBOX)

        this.sfxPath = sfxPath
        this.velocity = velocity*MISSILE_INTERVAL

        this.missileType = HOMING
        this.initDefaults()

    // Constructor for missile with location target
    construct(unit source, vec2 targetloc, string sfxPath, real velocity)
        this.source = source
        this.target = null

        this.targetLoc = targetloc
        this.targetZ = targetLoc.getTerrainZ()

        this.sfxPath = sfxPath
        this.velocity = velocity*MISSILE_INTERVAL

        this.missileType = TARGET
        this.initDefaults()

    ondestroy
        DummyRecycler.recycle(this.dummy)
        this.sfx.destr()
        this.t.release()

    function initDefaults()
        // Set missile origin and update current loc, distToTarget
        this.setOriginLoc(source.getPos())
        // Use setAngle for other initial angle
        this.setFacing(this.originLoc.angleTo(this.targetLoc).radians())


    // #####################################################
    // =================== Action funcs  ===================
    // #####################################################

    function onEnd()
        destroy this

    function onCollision(unit u)
        skip

    // Ensure that onEnd called if final target
    private function onTagetCollision(unit u)
        if u.getHandleId() == this.target.getHandleId()
            this.onEnd()

    function onPeriod()
        skip

    function onTimeExpire()
        destroy this

    // #####################################################
    // ===================== Setters  ======================
    // #####################################################

    /** Initial location (origin XY) of the missile  **/
    function setOriginLoc(vec2 loc)
        if this.currentLoc != this.originLoc
            // The missile have been moved, cant set a new origin.
            // TODO: debug print to avoid devel confusion
            return
        this.originLoc = loc
        this.currentLoc = originLoc
        this.distanceToTarget = this.originLoc.distanceTo(this.targetLoc)

    function setOriginZ(real z)
        if this.currentZ != this.originZ
            // The missile have been moved, cant set a new origin.
            // TODO: debug print to avoid devel confusion
            return
        this.originZ = z
        this.currentZ = this.originZ

    /** Initial facing of the missile  **/
    function setFacing(real radians)
        this.facing = radians

    /** Set the scale effect is created with on launch() or modify mid air **/
    function setScale(real scale)
        this.scale = scale
        if this.sfx != null
            this.sfx.setScale(scale)

    /** velocity is wc3 units/s  **/
    function setVelocity(real velocity)
        this.velocity = velocity*MISSILE_INTERVAL

    /** acceleration is wc3 units/s^2  **/
    function setAcceleration(real acceleration)
        this.acceleration = acceleration*MISSILE_INTERVAL

    /** turnrate is radians/s  **/
    function setTurnrate(real turnrate)
        this.turnrate = turnrate*MISSILE_INTERVAL

    /** turnrate acceleration in radians/s^2  **/
    function setTurnrateAcceleration(real turnrateAcceleration)
        this.turnrateAcceleration = turnrateAcceleration*MISSILE_INTERVAL

    /** arc as top height ratio of total length  **/
    function setArc(real arc)
        this.arc = arc

    /** time before self-destruct s  **/
    function setTimeToLive(real ttl)
        this.ttl = ttl

    // #####################################################
    // ===================== Getters  ======================
    // #####################################################

    function getPos() returns vec2
        return this.currentLoc

    function getZ() returns real
        return this.currentZ

    /** The effect is created on launch() returns null before **/
    function getSfx() returns effect
        return this.sfx

    function getTimeToLive() returns real
        return this.ttl

    // #####################################################
    // ====================== Missile ======================
    // #####################################################
    function launch()
        this.t = getTimer()
        this.dummy = DummyRecycler.get(this.originLoc, angle(this.facing))
        this.sfx = this.dummy.addEffect(this.sfxPath, "origin")
        this.sfx.setScale(this.scale)
        this.dummy.setFlyHeight(this.currentZ, 0)

        t.setData(this castTo int)
        t.startPeriodic(MISSILE_INTERVAL) ->
            timer t = GetExpiredTimer()
            Missile m = t.getData() castTo Missile

            real elapsedTime = t.getElapsed()
            m.liveTime += elapsedTime
            if m.liveTime > m.getTimeToLive()
                m.onTimeExpire()
            else if m.move()
                m.detectCollision()
                if m.missileType == MissileType.TARGET
                    m.detectEnd()

    function move() returns bool
        // Target unit destroyed => destroy missile
        if this.target == null and this.missileType == MissileType.HOMING
            // TODO: tagga inte lÃ¥ng, eller check if this runs
            print("Target null and HOMING =>")
            print("Call destroy")
            destroy this
            return false

        // Increase velocity
        this.velocity += acceleration
        // Increase turnrate with time, 0 by default
        this.turnrate += this.turnrateAcceleration

        // Update missile guidance to its intended target.
        if this.target != null
            this.updateTargetLoc()

        // Update the missile facing angle depending on the turnrate
        this.updateAngle()

        // Update missile location; returns false if outside map bounds => destroy
        if not this.updateMissileLocation()
            return false

        // Movement successful => start collision detection
        return true

    // #####################################################
    // ================= Missile movement ==================
    // #####################################################

    private function updateTargetLoc()
        // Update missile guidance to its intended target.
        this.targetLoc = this.target.getPos()
        this.targetZ = this.target.getLocalZ()

    private function updateAngle()
        // Update the missile facing angle depending on the turnrate
        // Angle is relative to the xy-plane.
        real targetAngle = currentLoc.angleTo(this.targetLoc).radians()

        // TODO: bug?
        if 0. != this.turnrate and Cos(this.facing - targetAngle) < Cos(this.turnrate)
            // Right or left angle correction?
            if 0. > Sin(targetAngle - this.facing)
                this.facing = this.facing - this.turnrate
            else
                this.facing = this.facing + this.turnrate
        else
            // If the angle correction is too small, we set the facing to the target angle.
            this.facing = targetAngle

        // Update the facing of the missile dummy.
        this.dummy.setFacing(angle(this.facing))

    private function updateMissileLocation() returns bool
        vec2 nextLoc = vec2(this.currentLoc.x + this.velocity*Cos(this.facing),
                            this.currentLoc.y + this.velocity*Sin(this.facing))

        // Destroy missile if next location is outside sentinel bounds
        if not nextLoc.inPlayable()
            print("destr sentinel bound")
            destroy this
            return false

        // Update distance traveled
        real stepDistance = nextLoc.distanceTo(this.currentLoc)
        this.distanceTraveled += stepDistance
        this.currentLoc = nextLoc
        this.distanceToTarget = this.currentLoc.distanceTo(this.targetLoc)

        // Move the missile dummy
        this.dummy.setPos(this.currentLoc)
        this.updateMissileZ(stepDistance)

        return true

    private function updateMissileZ(real stepDistance)
        real totDist = this.originLoc.distanceTo(this.targetLoc)
        // How close are we to the target compared ("%" along the way)
        real ratio = 1 - this.distanceToTarget/totDist
        // Ratio needs to be 0 <= ratio <= 1
        if ratio > 1
            ratio = 1
        else if ratio < 0
            ratio = 0

        // Update target z if unit
        if this.target != null
            this.targetZ = this.target.getLocalZ()

        // === Linear z diff ===
        real dzLine = 0
        // Missile has a downward slope but has gone below target => go back up
        if this.currentZ < this.targetZ and this.originZ > this.targetZ
            dzLine = 0.01
        // Missile correct (sort of exept if to high)
        else
            dzLine = (this.targetZ - this.originZ)*(stepDistance/totDist)

        // === Arc z diff ===
        real dzArc = PI*Cos(ratio*PI)*this.arc*stepDistance

        // Calculate pitch based on total change in z and change in xy-plane
        real pitch = Atan((dzLine + dzArc)/stepDistance)

        // Update z with both deltas
        this.currentZ += dzLine + dzArc

        // Set height of dummy and update pitch
        this.dummy.setFlyHeight(this.currentZ, 0)
        this.dummy.setAnimation((Rad2Deg(pitch) + 90).toInt())

    // #####################################################
    // ===================== Collision =====================
    // #####################################################

    protected function detectCollision()
        forUnitsInRange(this.currentLoc, COLLISION_SIZE) cbu ->
            // The pick selects units in a plane, filter units based on z-diff aswell
            if (this.currentZ - cbu.getUnitHeight(1)).abs() <= COLLISION_SIZE*2
                this.onCollision(cbu)
                // Ensure that onEnd called if final target
                this.onTagetCollision(cbu)

    protected function detectEnd()
        if this.currentLoc.distanceTo(this.targetLoc) <= COLLISION_SIZE
            this.onEnd()

// #####################################################
// ================ Random help funcs ==================
// #####################################################

/** percentage on decimal form (0.45 etc) **/
function unit.getUnitHeight(real percentage) returns real
    return 100*percentage