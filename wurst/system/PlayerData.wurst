package PlayerData

import LinkedList
import TypeCasting
import Assets
import SoundUtils
import ClosureForGroups

import Levels
import Colorscheme
import Regions
import Leaderboard
import Constants

class Remover implements ForGroupCallback
    function callback(unit u)
        u.remove()

class Winner implements ForGroupCallback
    function callback(unit u)
        u.setAnimation("stand victory")
        u.addEffect(Objects.toonBoom, "origin")
        // u.addEffect("Objects\\Spawnmodels\\Other\\ToonBoom\\ToonBoom.mdl", "origin")

public class PlayerData
    int playerNum
    player p
    int level
    int area
    int life
    int mobsRemoved
    unit builder
    bool levelInProgress

    construct(int playerNum, int level, int area, int life)
        this.playerNum = playerNum
        this.p = Player(playerNum)
        this.level = level
        this.area = area
        this.life = life
        this.mobsRemoved = 0
        this.levelInProgress = false

    function setBuilder(unit builder)
        this.builder = builder

    function loseLife(int i)
        if this.life >= 1
            this.life -= i
            if i > 1
                printTimedToPlayer(warningColor.colorize("You lost ") + numberColor.colorize(I2S(i)) + warningColor.colorize(" lives."), DISPLAY_TIME, this.p)
            else if i == 1
                printTimedToPlayer(warningColor.colorize("You lost ") + numberColor.colorize(I2S(i)) + warningColor.colorize(" life."), DISPLAY_TIME, this.p)
        else
            loseGame()

    function loseGame()
        printTimedToPlayer(infoColor.colorize("You have lost the game."), DISPLAY_TIME, this.p)
        this.levelInProgress = false
        this.cleanse()

    function winGame()
        printTimedToPlayer(infoColor.colorize("You won the game!"), DISPLAY_TIME, this.p)
        SoundDefinition sd = new SoundDefinition(Sounds.newTournament, false)
        sd.playForPlayer(this.p)
        rect r = rectFromIndex(playerArea.get(this.playerNum))
        Winner w = new Winner()
        forUnitsInRect(r, w)

    function cleanse()
        rect r = rectFromIndex(playerArea.get(this.playerNum))
        Remover rem = new Remover()
        forUnitsInRect(r, rem)

    function reset()
        this.levelInProgress = false
        this.area = 0
        this.life = STARTING_LIFE
        this.mobsRemoved = 0
        this.level = 0
        updateLife(this.p, this.life)

    function levelComplete()
        Level l = levels.get(this.level)

        this.levelInProgress = false
        this.builder.removeAbility(ID_LEVEL_IN_PROGRESS)

        this.level++
        this.mobsRemoved = 0

        // Win game
        if not this.level == levels.getSize()
            this.winGame()
            return

        if this.level == 1
            printTimedToPlayer(infoColor.colorize("You completed level info level."), DISPLAY_TIME, this.p)
        else
            printTimedToPlayer(infoColor.colorize("You completed level ")
            + numberColor.colorize(I2S(this.level))
            + infoColor.colorize(" and also received ")
            + numberColor.colorize(I2S(l.bounty))
            + infoColor.colorize(" gold as bounty!"), DISPLAY_TIME, this.p)

            // Reward bonus.
            this.p.addGold(l.bonus)

            // Play victory sound.
            SoundDefinition sd = new SoundDefinition(Sounds.questCompleted, false)
            sd.playForPlayer(this.p)

        this.builder.addAbility(ID_NEXT_LEVEL)

        // might change area later.

    function registerMobDeath()
        this.mobsRemoved++
        if this.mobsRemoved == levels.get(this.level).num
            levelComplete()

    function registerLeak()
        Level l = levels.get(this.level)
        this.p.addGold(l.bounty)
        let i = l.lifeLost
        loseLife(i)
        updateLife(this.p, this.life)

public LinkedList<PlayerData> playerData = new LinkedList<PlayerData>

init
    // Init player level tracker
    for i = 0 to NUMBER_OF_PLAYERS-1
        PlayerData pd = new PlayerData(i, 0, 0, STARTING_LIFE)
        playerData.add(pd)
